# binary tree
## classification

| 类型 | 特点 | 节点数 |
|------|-----|-------|
### 满二叉树
只有度为0的结点和度为2的结点，且度为0的结点在同一层上。

- 深度：k
- 节点数：$2^k - 1$

### 完全二叉树
除了底层节点可能没填满外，其余每层节点数都达到最大值，且最下层的节点都集中在该层最左边位置。
- 深度：k
- 最底层节点数：$1 \sim 2^{k-1}$

### 二叉搜索树
有序树：左子树 < 根结点 < 右子树
```angular2html
          10
        /    \
       6     16
      / \    / \
     3   9  14 19
```

### 平衡二叉树
左右两个子树的高差的绝对值不超过1

## 二叉树存储方式
### 链式存储
每个结点：
- 结点元素
- 左指针
- 右指针
```python
class TreeNode:
    def __init__(self, val, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right
```
### 顺序存储
用数组来存储二叉树。<br>
索引顺序：从上到下，从左到右，依次递增

- 父节点：idx = i
- 左子结点：idx = i * 2 + 1
- 右子结点：idx = i * 2 + 2

## 二叉树遍历方式
### 深度优先遍历（递归/迭代）
```angular2html
          5
        /    \
       4      6
      / \    / \
     1   2  7   8
```
前中后，指的就是中间节点的遍历顺序

| 遍历方式 | 顺序  | example       |
|------|-----|---------------|
| 前序遍历 | 中左右 | 5 4 1 2 6 7 8 |
| 中序遍历 | 左中右 | 1 4 2 5 7 6 8 |
| 后序遍历 | 左右中 | 1 2 4 7 8 6 5 |

### 广度优先遍历（迭代）
队列：FIFO 先进先出
## 递归遍历
[144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/671394618/)<br>
[94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)<br>
[145.二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)<br>

### 递归三要素
1. 确定递归函数的**参数**和**返回值**  
   2. 传入的参数为：一般是 根结点、数组（用于存放遍历结果）
   3. 返回值：一般都是void，因为结果放到了参数里
2. 确定终止条件：当前遍历的节点为空，本层递归结束 `if cur == null`
3. 确定单层递归的逻辑：前序遍历/中序遍历/后序遍历

## 迭代遍历
[二叉树的迭代遍历](https://programmercarl.com/二叉树的迭代遍历.html#算法公开课)

通过循环和数据结构（栈/队列）手动模拟计算过程。需要显示给出数据的进出的栈/队列

前序遍历：中左右 （访问节点和处理节点可以同步处理）
- 根节点放入栈中
- 右子节点加入栈
- 左子节点加入栈
- 栈空的时候结束

中序遍历：左中右
- 借助指针（中间节点）的遍历来访问节点，栈处理节点上的元素
- 通过指针遍历到最左边的节点
- 指针访问节点
- 指针转向右子节点

后序遍历：左右中
- 思路：先序遍历（中左右） -> 调整代码左右顺序（中右左） -> 反转result数组（左右中）


考虑迭代的情况：
- 树深度很深，担心栈溢出
- 问题本身更适合迭代思路，如BFS
